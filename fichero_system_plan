# üìÑ Fichero Processing System: Full System Design (Detailed Markdown Version)

---

# üí™ Project Goal

We are building **Fichero**, a scalable, resilient document processing system designed to:

* Handle tens of thousands of files (up to 61,000+)
* Organize documents into **folders** (e.g., legal cases)
* Process documents **independently and in parallel**
* Post-process **entire folders** when files are complete
* Be controllable via **GUI or CLI**
* Be **reliable, fault-tolerant, and recoverable**
* **Scale** cleanly with CPUs and GPUs

---

# üîç Architecture Overview

| Layer                      | Role                                              |
| :------------------------- | :------------------------------------------------ |
| GUI (wxPython)             | User starts processing and monitors progress      |
| CLI (fichero\_cli.py)      | Parses inputs, calls the controller               |
| Controller (controller.py) | Dynamically builds Weasel flows per file          |
| Weasel                     | Runs tasks, manages concurrency, retries failures |
| Monitor (monitor.py)       | Watches fichero.jsonl for folder completion       |
| fichero.jsonl              | Central file recording per-file status            |

---

# üåê Detailed Workflow

1. User selects a folder of files in GUI or terminal CLI.
2. GUI calls the CLI with folder path and settings (CPUs, GPU usage).
3. CLI invokes **Controller**, which:

   * Scans the selected folder.
   * **Creates a Weasel flow per file** (Rotate, Enhance, Segment, OCR, Clean).
   * Launches all flows with **controlled concurrency**.
4. Each **Weasel task** updates **fichero.jsonl** with file progress.
5. **Separate Monitor process**:

   * Reads fichero.jsonl every few seconds.
   * Groups files by folder.
   * Triggers **folder-level flows** (Merge texts, Create PDFs, Archive) once all files in a folder are "done".
6. **GUI** polls fichero.jsonl and shows real-time updates.

---

# üìÇ Key Files and Roles

| File                     | Purpose                                          |
| :----------------------- | :----------------------------------------------- |
| fichero\_gui.py          | wxPython GUI frontend                            |
| fichero\_cli.py          | Command-line interface frontend                  |
| controller.py            | Builds and manages Weasel flows dynamically      |
| monitor.py               | Separate process that monitors folder completion |
| steps/rotate.py          | Rotate image task                                |
| steps/enhance.py         | Image enhancement task                           |
| steps/segment.py         | Document segmentation task                       |
| steps/ocr.py             | OCR task                                         |
| steps/clean.py           | Cleaning/postprocessing task                     |
| steps/folder\_merge.py   | Merge texts per folder                           |
| steps/folder\_pdf.py     | Create final PDFs                                |
| steps/folder\_archive.py | Zip/Archive folder                               |
| jsonl\_manager.py        | Safe read/write operations for fichero.jsonl     |

---

# üìö fichero.jsonl Format

Each line is one file:

```json
{
  "input_path": "/cases/case001/page_001.jpg",
  "folder": "case001",
  "rotation": 90,
  "enhanced": "/cases/case001/enhanced_page_001.jpg",
  "segments": [...],
  "transcription": "Extracted text...",
  "status": "done"
}
```

Fields:

* `input_path`: original file path
* `folder`: folder (case) name
* `status`: task completion status ("done", "error", etc.)

---

# üåÄ File-Level Processing (per file)

Each file gets its **own Weasel flow**:

```text
Rotate ‚ûî Enhance ‚ûî Segment ‚ûî OCR ‚ûî Clean
```

* Tasks run in order.
* Retry on failure is automatic.
* Progress is recorded after each step.

---

# üåÄ Folder-Level Processing (per folder)

When all files in a folder are complete:

```text
Merge Transcriptions ‚ûî Create PDF ‚ûî Archive Folder
```

* The Monitor triggers a **new Weasel flow** for the folder.
* Folder-level actions are reliable and sequential.

---

# üöÄ Parallelism and Scaling

| Problem                             | Solution                                                    |
| :---------------------------------- | :---------------------------------------------------------- |
| 61,000+ files?                      | Concurrency control in Weasel (e.g., 8-64 concurrent flows) |
| Writing conflicts in fichero.jsonl? | `multiprocessing.Lock()` or batched safe writes             |
| Folder needs to wait?               | Monitor watches and triggers folder flows                   |
| Slow steps?                         | Fine, because each file is independent                      |
| GPUs/CPUs?                          | Assign specific GPUs to workers with environment variables  |

**RAM usage?**

* Loading 61k file entries = \~200-500 MB RAM.
* Fine on modern systems.

---

# üèãÔ∏è Control Flow Diagram

```
[GUI/CLI]
   ‚îî‚îÄ‚îÄ Launches Controller ‚îÄ‚îÄ‚îî‚îÄ‚îÄ Build Weasel Flows
                                        ‚îî‚îÄ‚îÄ Start Weasel Workers
[Monitor]
   ‚îî‚îÄ‚îÄ Watches fichero.jsonl
           ‚îî‚îÄ‚îÄ Triggers Folder Flows when Ready
```

---

# ‚ú® Summary in One Sentence

> **Fichero** dynamically creates per-file Weasel flows for processing, monitors per-folder completion via fichero.jsonl, and triggers final folder workflows automatically, all coordinated through a clean GUI or CLI.

---

# üõ†Ô∏è Immediate Next Build Steps

1. **Create fichero\_cli.py** to launch controller.
2. **Create controller.py** to dynamically build flows.
3. **Write monitor.py** to watch fichero.jsonl and trigger folders.
4. **Write safe jsonl\_manager.py** to handle concurrent writes.
5. **Expand steps/rotate.py, steps/enhance.py, etc.**
6. **Connect fichero\_gui.py** to CLI via subprocess.
7. **Test with 3 folders, each with 5 files, to validate logic.**

---

# üîç Notes for Cursor.ai Instructions

* Focus on **dynamic Python Weasel flows**, **no YAML**.
* Focus on **file-level independence** + **folder-level post-processing**.
* Use **multiprocessing.Lock()** for safe concurrent fichero.jsonl updates.
* Optimize **GUI polling** every 2 seconds for user feedback.
* Prepare for **batch updating** to fichero.jsonl if needed for speed.

---

# üèÜ You Are Now Building a Production-Ready Processing System!

Once implemented, **Fichero** will:

* Process tens of thousands of documents efficiently
* Scale across CPUs and GPUs
* Be crash-recoverable
* Be cross-platform (macOS, Linux, Windows)
* Have a beautiful GUI and a CLI for automation

---

# üöÄ Let's Build It!

# Notes
Completd: jsonl\_manager.py        Safe read/write operations for documents_manifest.jsonl
